(self.webpackChunkcodeshift_community=self.webpackChunkcodeshift_community||[]).push([[216],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return c},kt:function(){return d}});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var s=r.createContext({}),l=function(n){var e=r.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):p(p({},e),n)),t},c=function(n){var e=l(n.components);return r.createElement(s.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,a=n.originalType,s=n.parentName,c=i(n,["components","mdxType","originalType","parentName"]),m=l(t),d=o,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return t?r.createElement(f,p(p({ref:e},c),{},{components:t})):r.createElement(f,p({ref:e},c))}));function d(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var a=t.length,p=new Array(a);p[0]=m;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=n,i.mdxType="string"==typeof n?n:o,p[1]=i;for(var l=2;l<a;l++)p[l]=t[l];return r.createElement.apply(null,p)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3520:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return p},metadata:function(){return i},toc:function(){return s},default:function(){return c}});var r=t(2122),o=t(9756),a=(t(7294),t(3905)),p={id:"react",title:"React & JSX",slug:"/react"},i={unversionedId:"recipes/react",id:"recipes/react",isDocsHomePage:!1,title:"React & JSX",description:"Props",source:"@site/docs/recipes/react.mdx",sourceDirName:"recipes",slug:"/react",permalink:"/docs/react",editUrl:"https://github.com/CodeshiftCommunity/CodeshiftCommunity/edit/main/website/docs/recipes/react.mdx",version:"current",frontMatter:{id:"react",title:"React & JSX",slug:"/react"},sidebar:"docs",previous:{title:"Import manipulation",permalink:"/docs/import-manipulation"}},s=[{value:"Props",id:"props",children:[{value:"Inserting props",id:"inserting-props",children:[]},{value:"Removing props",id:"removing-props",children:[]},{value:"Replacing props",id:"replacing-props",children:[]},{value:"Rest props",id:"rest-props",children:[]}]},{value:"JSX",id:"jsx",children:[{value:"Wrapping components",id:"wrapping-components",children:[]},{value:"Inserting children nodes",id:"inserting-children-nodes",children:[]},{value:"Render props",id:"render-props",children:[]}]}],l={toc:s};function c(n){var e=n.components,t=(0,o.Z)(n,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},l,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"props"},"Props"),(0,a.kt)("h3",{id:"inserting-props"},"Inserting props"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.JSXElement)\n    // Find all components called button\n    .filter(path => path.value.openingElement.name.name === 'button')\n    .forEach(element => {\n      const newComponent = j.jsxElement(\n        j.jsxOpeningElement(element.node.openingElement.name, [\n          ...element.node.openingElement.attributes,\n          // build and insert our new prop\n          j.jsxAttribute(j.jsxIdentifier('disabled'), j.stringLiteral('true')),\n        ]),\n        element.node.closingElement,\n        element.node.children,\n      );\n\n      // Replace our original component with our modified one\n      j(element).replaceWith(newComponent);\n    });\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\n\nconst Button = props => {\n  return <button className=\"button\">Submit</button>;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'import React from \'react\';\n\nconst Button = props => {\n-  return <button className="button">Submit</button>;\n+  return <button className="button" disabled="true">Submit</button>;\n};\n')),(0,a.kt)("h3",{id:"removing-props"},"Removing props"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.JSXElement)\n    .filter(path => path.value.openingElement.name.name === 'button') // Find all button jsx elements\n    .find(j.JSXAttribute) // Find all attributes (props) on the button\n    .filter(path => path.node.name.name === 'onClick') // Filter to only props called onClick\n    .remove(); // Remove everything that matched\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\n\nconst Button = props => {\n  return (\n    <button className=\"button\" onClick={() => console.log('Hello, World!')}>\n      Submit\n    </button>\n  );\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"import React from 'react';\n\nconst Button = props => {\n-  return <button className=\"button\" onClick={() => console.log('Hello, World!')}>Submit</button>;\n+  return <button className=\"button\">Submit</button>;\n};\n")),(0,a.kt)("h3",{id:"replacing-props"},"Replacing props"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\n\nconst Button = props => {\n  return <button className=\"button\">Submit</button>;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'import React from \'react\';\n\nconst Button = props => {\n-  return <button className="button">Submit</button>;\n+  return <button className="button button-primary">Submit</button>;\n};\n')),(0,a.kt)("h3",{id:"rest-props"},"Rest props"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n  const props = [];\n\n  source\n    // Find all jsx elements with the name \"button\"\n    .find(j.JSXElement)\n    .filter(path => path.node.openingElement.name.name === 'button')\n    // Collect all of their props\n    .forEach(path => props.push(...path.node.openingElement.attributes))\n    // Now get all of the jsx attributes (props)...\n    .find(j.JSXAttribute)\n    // And replace them with a spread attribute called \"props\" for example `{...props}`\n    .forEach(path => path.replace(j.jsxSpreadAttribute(j.identifier('props'))));\n\n  // Create a new constant variable named props.\n  const variableDeclaration = j.variableDeclaration('const', [\n    j.variableDeclarator(\n      j.identifier('props'),\n      // the variable will be assigned an object containing all of the props from button\n      j.objectExpression(\n        props.map(prop =>\n          j.objectProperty(\n            j.identifier(prop.name.name),\n            j.stringLiteral(prop.value.value),\n          ),\n        ),\n      ),\n    ),\n  ]);\n\n  // Finally, we find the arrow function expression\n  source\n    .find(j.ArrowFunctionExpression)\n    // We then retrieve its body, which is the \"block scope\" of the component\n    .get('body')\n    // Since elements in a block are an array, we need to insert our new variable using unshift because we want it to be first\n    .value.body.unshift(variableDeclaration);\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\n\nconst Button = () => {\n  return <button className=\"button\">Submit</button>;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"import React from 'react';\n\nconst Button = () => {\n+  const props = { className: 'button' };\n-  return <button className=\"button\">Submit</button>;\n+  return <button {...props}>Submit</button>;\n};\n")),(0,a.kt)("h2",{id:"jsx"},"JSX"),(0,a.kt)("h3",{id:"wrapping-components"},"Wrapping components"),(0,a.kt)("p",null,"Wrapping react components with react components is a fairly common opperation."),(0,a.kt)("p",null,"Simply follow this fairly simple set of steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Find the component you want to wrap"),(0,a.kt)("li",{parentName:"ol"},"Create a new component and pass the component to be wrapped in as a child node"),(0,a.kt)("li",{parentName:"ol"},"Replace the original component with a wrapped version of itself")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Find all components named \"Avatar\"\n  source.findJSXElements('Avatar').forEach(element => {\n    // Create a new JSXElement called \"Tooltip\" and use the original Avatar component as children\n    const wrappedAvatar = j.jsxElement(\n      j.jsxOpeningElement(j.jsxIdentifier('Tooltip'), [\n        // Create a prop on the tooltip so it works as expected\n        j.jsxAttribute(\n          j.jsxIdentifier('content'),\n          j.stringLiteral('Hello, there!'),\n        ),\n      ]),\n      j.jsxClosingElement(j.jsxIdentifier('Tooltip')),\n      [element.value], // Pass in the original component as children\n    );\n\n    j(element).replaceWith(wrappedAvatar);\n  });\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Avatar, Tooltip } from 'component-lib';\n\nconst App = () => {\n  return <Avatar name=\"foo\" />;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'import {Avatar, Tooltip } from \'component-lib\';\n\nconst App = () => {\n  return (\n+    <Tooltip content="foo">\n      <Avatar name="foo" />\n+    </Tooltip>\n  );\n}\n')),(0,a.kt)("h3",{id:"inserting-children-nodes"},"Inserting children nodes"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.JSXElement) // Find all jsx elements\n    .filter(path => path.node.openingElement.name.name === 'ul') // filter to an array of only ul elements\n    .forEach(path =>\n      // Replace each ul element with a modified version of itself\n      path.replace(\n        j.jsxElement(path.node.openingElement, path.node.closingElement, [\n          ...path.node.children, // Copy existing children\n          // Create a new li element containing our new entry\n          j.jsxElement(\n            j.jsxOpeningElement(j.jsxIdentifier('li')),\n            j.jsxClosingElement(j.jsxIdentifier('li')),\n            [j.stringLiteral('Venusaur')],\n          ),\n          j.jsxText('\\n'), // Add this to tidy up the formatting\n        ]),\n      ),\n    );\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\n\nconst Button = () => {\n  return (\n    <ul>\n      <li>Bulbasaur</li>\n      <li>Ivysaur</li>\n    </ul>\n  );\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"import React from 'react';\n\nconst Button = () => {\n  return (\n    <ul>\n      <li>Bulbasaur</li>\n      <li>Ivysaur</li>\n+     <li>Venusaur</li>\n    </ul>\n  );\n};\n")),(0,a.kt)("h3",{id:"render-props"},"Render props"),(0,a.kt)("p",null,"Moving between different types of React composition strategies, like for example, from component props to ",(0,a.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/render-props.html#using-props-other-than-render"},"render props")," is could be something you want to do between major versions.\nThis might seem difficult on the surface, but think about it like every other codemod. First we need to find the component, replace it with a modified copy of itself and finally insert a function as children."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Transform:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { getJSXAttributes } from '@codeshift/utils';\n\nexport default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source.findJSXElements('Avatar').forEach(element => {\n    // Find props all JSXAttributes with a prop called \"component\"\n    // (Using the getJSXAttributeByName util here for simplicity)\n    const componentProp = getJSXAttributes(j, element, 'component').get();\n    // Grabs the name of the component passed into the \"component\" prop\n    const componentName = j(componentProp)\n      .find(j.JSXExpressionContainer)\n      .find(j.Expression)\n      .get().value.name;\n\n    // Remove it since it's no longer required on the wrapping component\n    j(componentProp).remove();\n\n    // Create a new child component based on the component prop and spread props onto it\n    const customComponent = j.jsxElement(\n      j.jsxOpeningElement(\n        j.jsxIdentifier(componentName),\n        [j.jsxSpreadAttribute(j.identifier('props'))],\n        true,\n      ),\n    );\n\n    /**\n     * Here's where it gets interesting.\n     * We create a render prop function and pass in `customComponent` as the return value\n     */\n    const childrenExpression = j.jsxExpressionContainer(\n      j.arrowFunctionExpression([j.identifier('props')], customComponent),\n    );\n\n    /**\n     * Then finally, we replace our original component with the following.\n     * Taking properties from the original component and combining them with our new render prop function\n     */\n    j(element).replaceWith(\n      j.jsxElement(\n        j.jsxOpeningElement(\n          element.value.openingElement.name,\n          element.value.openingElement.attributes,\n          false,\n        ),\n        j.jsxClosingElement(element.value.openingElement.name),\n        [childrenExpression],\n      ),\n    );\n  });\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import Avatar from '@component-lib/avatar';\n\nconst App = () => {\n  return <Avatar name=\"Dan\" component={CustomAvatar} />;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'\nimport Avatar from \'@component-lib/avatar\';\n\nconst App = () => {\n  return (\n-    <Avatar name="Dan" component={CustomAvatar} />\n+    <Avatar name="Dan">{props => <CustomAvatar {...props} />}</Avatar>\n+  );\n}\n')))}c.isMDXComponent=!0}}]);