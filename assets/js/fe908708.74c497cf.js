(self.webpackChunkcodeshift_community=self.webpackChunkcodeshift_community||[]).push([[638],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,f=m["".concat(l,".").concat(d)]||m[d]||c[d]||i;return n?o.createElement(f,a(a({ref:t},u),{},{components:n})):o.createElement(f,a({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var p=2;p<i;p++)a[p]=n[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8081:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return a},metadata:function(){return s},toc:function(){return l},default:function(){return u}});var o=n(2122),r=n(9756),i=(n(7294),n(3905)),a={id:"authoring",title:"Authoring",slug:"/authoring"},s={unversionedId:"authoring",id:"authoring",isDocsHomePage:!1,title:"Authoring",description:"Before writing a codemod, please read the contribution guide \ud83d\ude4f",source:"@site/docs/authoring.mdx",sourceDirName:".",slug:"/authoring",permalink:"/docs/authoring",editUrl:"https://github.com/CodeshiftCommunity/CodeshiftCommunity/edit/main/website/docs/authoring.mdx",version:"current",frontMatter:{id:"authoring",title:"Authoring",slug:"/authoring"},sidebar:"docs",previous:{title:"Glossary",permalink:"/docs/glossary"},next:{title:"Consuming",permalink:"/docs/consuming"}},l=[{value:"Initializing",id:"initializing",children:[]},{value:"File structure",id:"file-structure",children:[]},{value:"Configuration",id:"configuration",children:[]},{value:"Versioning",id:"versioning",children:[]},{value:"Transformers",id:"transformers",children:[]},{value:"Motions",id:"motions",children:[]},{value:"Testing",id:"testing",children:[]}],p={toc:l};function u(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Before writing a codemod, please read the ",(0,i.kt)("a",{parentName:"p",href:"docs/contribution"},"contribution guide")," \ud83d\ude4f"),(0,i.kt)("h2",{id:"initializing"},"Initializing"),(0,i.kt)("p",null,"Create a folder structure for your new codemod by running:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"yarn codeshift:init -p [package-name] -v [version]")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"yarn init:codemods react-cool-library 10.0.0")),(0,i.kt)("p",null,"And for scoped packages:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"yarn init:codemods @scope/react-cool-library 10.0.0")),(0,i.kt)("p",null,"It will create a package within the ",(0,i.kt)("inlineCode",{parentName:"p"},"/community")," subdirectory, this is for you to implement your codemod."),(0,i.kt)("h2",{id:"file-structure"},"File structure"),(0,i.kt)("p",null,"The file structure of your codemod will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"community/[package-name]/[version]\n  /codeshift.config.js // main entrypoint containing configuration and references to your transforms\n  /transform.ts // main logic (should contain a transformer)\n  /transform.spec.ts // main tests\n  /motions // different operations that make up the codemod\n    /[motion-name].ts // motion\n    /[motion-name].spec.ts // motion tests\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"community/react-cool-library/18.0.0\n  /codeshift.config.js\n  /transform.ts\n  /transform.spec.ts\n  /motions\n    /remove-ref-usage.ts\n    /remove-ref-usage.spec.ts\n")),(0,i.kt)("h2",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"Each codemod package should be coupled with a ",(0,i.kt)("inlineCode",{parentName:"p"},"codeshift.config.js")," file.\nThe config file is the entry-point of your codemod and is responsible for holding all of the relevant\nmetadata about it, as well as references to the transformer functions themselves."),(0,i.kt)("p",null,"They typically look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export default {\n  maintainers: ['danieldelcore'],\n  transforms: {\n    '18.0.0': require.resolve('./18.0.0/transform'),\n    '19.0.0': require.resolve('./19.0.0/transform'),\n  },\n};\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"maintainers"),": Github usernames of the people that maintain that codemod, they will be notified on PRs etc."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transforms"),": A key value pair of transforms organized by semver-compatible versions")),(0,i.kt)("h2",{id:"versioning"},"Versioning"),(0,i.kt)("p",null,"You might wonder why we require that codemods are named by a semver version like ",(0,i.kt)("inlineCode",{parentName:"p"},"react-cool-library/18.0.0"),".\nWe believe that codemods should aim to target specific package and versions of that package."),(0,i.kt)("p",null,"This is done to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Make it obvious what the intended purpose and scope of a codemod is"),(0,i.kt)("li",{parentName:"ul"},"Make it obvious which package is being upgraded"),(0,i.kt)("li",{parentName:"ul"},"Make it easy to play codemods in sequence to allow migration from v4 -> v5 -> v6")),(0,i.kt)("p",null,"But importantly, in terms of authoring, this also allows us to ",(0,i.kt)("strong",{parentName:"p"},"retrospectivally patch published codemods"),".\nPatched codemods will then be automatically published when merged to the repo, ensuring that consumers are always running the latest version."),(0,i.kt)("h2",{id:"transformers"},"Transformers"),(0,i.kt)("p",null,"Transformers are the main entrypoint to your codemod, they are responsible for accepting a raw file, applying the appropriate modifications to it and finally outputting the resulting AST to the original file."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { hasImportDeclaration } from '@codeshift/utils';\nimport updateBorderWidth from './motions/update-border-width';\n\nexport default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  if (!hasImportDeclaration(j, source, 'my')) {\n    return file.source; // Writes original untouched file\n  }\n\n  // Checks if the file needs to be modified\n  updateBorderWidth(j, source); // Execute individual motions\n\n  return source.toSource(options.printOptions); // Writes modified AST to file\n}\n")),(0,i.kt)("h2",{id:"motions"},"Motions"),(0,i.kt)("p",null,"A motion (aka migration) is what we call specific actions performed within a codemod. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"updateBorderWidth")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"removeDeprecatedProps"),".\nThey can be simply thought of a functions that are responsible for a single action within a codemod. It is not required but they are highly recommended as\na helpful design pattern to isolate more complicated parts of your codemod into discrete pieces."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function removeDeprecatedProps(j, source) {\n  // Some logic here\n}\n")),(0,i.kt)("p",null,"Motions can then be applied from the main transform, just like any other function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { hasImportDeclaration } from '@codeshift/utils';\nimport removeDeprecatedProps from './motions/remove-deprecated-props';\nimport restructureImports from './motions/restructure-imports';\n\nexport default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Execute individual motions\n  removeDeprecatedProps(j, source);\n  restructureImports(j, source);\n\n  return source.toSource(options.printOptions); // Writes modified AST to file\n}\n")),(0,i.kt)("p",null,"Each motion receives a reference to the AST (",(0,i.kt)("inlineCode",{parentName:"p"},"source"),") which it can then manipulate as required."),(0,i.kt)("p",null,"Alternatively, you can use the utility function ",(0,i.kt)("a",{parentName:"p",href:"./utils#applymotionsj-source-motions"},"applyMotions")," to run motions in sequence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { applyMotions } from '@codeshift/utils';\nimport removeDeprecatedProps from './motions/remove-deprecated-props';\nimport restructureImports from './motions/restructure-imports';\n\nexport default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Execute a series of motions in order\n  applyMotions(j, source, [removeDeprecatedProps, restructureImports]);\n\n  return source.toSource(options.printOptions);\n}\n")),(0,i.kt)("h2",{id:"testing"},"Testing"),(0,i.kt)("p",null,"It's very likely that consumers will run into all sorts of edge-cases when running your transform.\nThat's why it's important to start by writing some tests to assert it's behavior. Luckily, both ",(0,i.kt)("a",{parentName:"p",href:"./test-utils"},"CodeshiftCommunity")," & ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/jscodeshift#unit-testing"},"jscodeshift")," provides testing utilities to help."),(0,i.kt)("p",null,"When creating a codemod, it's best to always try to write your tests first (TDD style).\nThink about the start and end state and how you might be able to achieve that. Also, make sure to consider as many edge-cases as you possibly can."),(0,i.kt)("p",null,"For more information, please see the ",(0,i.kt)("a",{parentName:"p",href:"testing"},"testing docs"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { applyTransform } from '@codeshift/test-utils';\n\nimport * as transformer from '../transform';\n\ndescribe('MyTransform', () => {\n  it('should wrap component in a tooltip if name is defined', () => {\n    const result = applyTransform(\n      transformer,\n      `\n      import MyComponent from 'my-component';\n\n      const App = () => {\n        return <MyComponent name=\"foo\" />;\n      }\n    `,\n      { parser: 'tsx' },\n    );\n\n    expect(result).toMatchInlineSnapshot(`\n    \"import Tooltip from 'my-tooltip';\n    import MyComponent from 'my-component';\n\n    const App = () => {\n      return <Tooltip content=\\\\\"foo\\\\\"><MyComponent name=\\\\\"foo\\\\\" /></Tooltip>;\n    }\"\n  `);\n  });\n});\n")))}u.isMDXComponent=!0}}]);