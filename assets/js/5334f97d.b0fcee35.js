(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var o=n(3),r=n(7),i=(n(0),n(95)),a={id:"your-first-codemod",title:"Your first codemod",slug:"/your-first-codemod"},s={unversionedId:"guides/your-first-codemod",id:"guides/your-first-codemod",isDocsHomePage:!1,title:"Your first codemod",description:"Every codemod follows fundamentally the same series of operations: find, modify/insert/remove and finally output.",source:"@site/docs/guides/your-first-codemod.mdx",slug:"/your-first-codemod",permalink:"/CodeshiftCommunity/docs/your-first-codemod",editUrl:"https://github.com/CodeshiftCommunity/CodeshiftCommunity/edit/master/website/docs/guides/your-first-codemod.mdx",version:"current",sidebar:"docs",previous:{title:"Ecosystem",permalink:"/CodeshiftCommunity/docs/ecosystem"},next:{title:"Understanding ASTs",permalink:"/CodeshiftCommunity/docs/understanding-asts"}},c=[{value:"Setup",id:"setup",children:[]},{value:"Find",id:"find",children:[]},{value:"Modify",id:"modify",children:[]},{value:"Insert",id:"insert",children:[]},{value:"Remove",id:"remove",children:[]},{value:"Output",id:"output",children:[]}],u={toc:c};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Every codemod follows fundamentally the same series of operations: find, modify/insert/remove and finally output.\nThat's it. Once you know how to handle all of these operations you can do anything within a codemod."),Object(i.b)("h2",{id:"setup"},"Setup"),Object(i.b)("p",null,'Firstly you\'ll need to define to create a new file with which defines a "transform" function. A transform is simply a javascript function which serves as the entry-point for your codemod.'),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"export default function transform(file, api, options) {\n  //... codemod goes here\n}\n")),Object(i.b)("h2",{id:"find"},"Find"),Object(i.b)("p",null,"Finding specific nodes within your file can be a strange experience for those who have never worked with ASTs before."),Object(i.b)("p",null,"For example, lets try and locate a ",Object(i.b)("inlineCode",{parentName:"p"},"JSXIdentifier")," with the name ",Object(i.b)("inlineCode",{parentName:"p"},"isDisabled"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"export default function transform(file, api, options) {\n  const j = api.jscodeshift;\n  const source = j(file.source);\n\n  source.find(j.JSXIdentifier).forEach(path => {\n    if (path.node.name === 'isDisabled') {\n      // \ud83c\udf89 Tada we found it, we can now modify/insert/remove this node\n    }\n  });\n\n  return source.toSource(options.printOptions); // We return the modified file\n}\n")),Object(i.b)("h2",{id:"modify"},"Modify"),Object(i.b)("h2",{id:"insert"},"Insert"),Object(i.b)("h2",{id:"remove"},"Remove"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"export default function transform(file, api, options) {\n  const j = api.jscodeshift;\n  const source = j(file.source);\n\n  source.find(j.JSXIdentifier).forEach(path => {\n    if (path.node.name === 'isDisabled') {\n      j(path).remove(); // We remove the `isDisabled` prop from the AST\n    }\n  });\n\n  return source.toSource(options.printOptions);\n}\n")),Object(i.b)("h2",{id:"output"},"Output"),Object(i.b)("p",null,"At the end of your transform, you call and return the result of the ",Object(i.b)("inlineCode",{parentName:"p"},"j(file.source).toSource()")," method. When this function is called, it will traverse your AST and output a javascript (or typescript) source file. The result of which will include all of the modifications you made."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"export default function transform(file, api, options) {\n  const j = api.jscodeshift;\n  const source = j(file.source);\n\n  // ...\n\n  return source.toSource(options.printOptions); // Output your file here\n}\n")),Object(i.b)("p",null,"This method, accepts some ",Object(i.b)("a",{parentName:"p",href:"https://github.com/benjamn/recast/blob/52a7ec3eaaa37e78436841ed8afc948033a86252/lib/options.js#L61"},"options for formatting"),".\nCodeshift uses recast under the hood, which tries it's best to format output code as close to the original file as possible. But it's often good to run your formatter of choice after running the codemod to be completely sure."),Object(i.b)("p",null,"To avoid formatting issues and to speed up running transforms across large codebases, it's good practice to only modify the files you need to."),Object(i.b)("p",null,'For example, in cases where the code you want to change does not exist in the file your attempting to transform, you should bail early and return the "raw" source file.'),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"export default function transform(file, api, options) {\n  const source = j(fileInfo.source);\n  const hasIsDisabledProp = !!source.find(j.JSXIdentifier).filter(path.node.name === 'isDisabled').length\n\n  if (!hasIsDisabledProp) {\n    return fileInfo.source; // Returns original source file, untouched and unformatted\n  }\n\n  // transform code goes here...\n\n  return source.toSource(options.printOptions);\n")))}d.isMDXComponent=!0},95:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return m}));var o=n(0),r=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=r.a.createContext({}),d=function(e){var t=r.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=d(e.components);return r.a.createElement(u.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),l=d(n),p=o,m=l["".concat(a,".").concat(p)]||l[p]||f[p]||i;return n?r.a.createElement(m,s(s({ref:t},u),{},{components:n})):r.a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var u=2;u<i;u++)a[u]=n[u];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);