(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{81:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return l}));var o=t(3),r=t(7),i=(t(0),t(95)),a={id:"guiding-principles",title:"Guiding principles",slug:"/guiding-principles"},s={unversionedId:"guiding-principles",id:"guiding-principles",isDocsHomePage:!1,title:"Guiding principles",description:"There are several guiding principles we follow in this project.",source:"@site/docs/guiding-principles.mdx",slug:"/guiding-principles",permalink:"/docs/guiding-principles",editUrl:"https://github.com/CodeshiftCommunity/CodeshiftCommunity/edit/master/website/docs/guiding-principles.mdx",version:"current",sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/"},next:{title:"FAQ",permalink:"/docs/faq"}},c=[{value:"Codemods should target a version of package",id:"codemods-should-target-a-version-of-package",children:[]},{value:"Codemods should be playable in sequence",id:"codemods-should-be-playable-in-sequence",children:[]},{value:"Codemods should do as much as can be safely done, automatically and prompt for human intervention when needed",id:"codemods-should-do-as-much-as-can-be-safely-done-automatically-and-prompt-for-human-intervention-when-needed",children:[]}],d={toc:c};function l(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"There are several guiding principles we follow in this project."),Object(i.b)("h2",{id:"codemods-should-target-a-version-of-package"},"Codemods should target a version of package"),Object(i.b)("p",null,"Code is always on the move and codemods written against a specific API, at a specific point of time aren't guaranteed to work in the future.\nWe believe codemods should only aim to migrate from one API to another, by limiting the scope of change to a specific package and version.\nIn doing so the scope and intent of a codemod is encoded and always obvious to users."),Object(i.b)("h2",{id:"codemods-should-be-playable-in-sequence"},"Codemods should be playable in sequence"),Object(i.b)("p",null,"By writing codemods that target a package and version, it should then be possible to move consumers across major versions by playing them in a sequence.\nFor example, migrating from an older version of ",Object(i.b)("inlineCode",{parentName:"p"},"@mylib/button")," to the latest is possible by playing all available codemods in order ",Object(i.b)("inlineCode",{parentName:"p"},"v14 -> v15 -> v16"),"."),Object(i.b)("h2",{id:"codemods-should-do-as-much-as-can-be-safely-done-automatically-and-prompt-for-human-intervention-when-needed"},"Codemods should do as much as can be safely done, automatically and prompt for human intervention when needed"),Object(i.b)("p",null,"Writing a codemod to completely migrate a package from one working state to another is not always feasible. Some edgecases might simply be too hard to support.\nSo when this is the case, bailing out and pompting for human intervention should be your first fallback.\nThis gives consumers a chance to review the changes of the codemod, read the prompts containing context about the changes they need to action and make the remaining manual steps as painless and straight forward as possible."),Object(i.b)("p",null,"For more information, please see the ",Object(i.b)("a",{parentName:"p",href:"/docs/prompting-for-human-input"},"Prompting for human input")," guide."))}l.isMDXComponent=!0},95:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return f}));var o=t(0),r=t.n(o);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=r.a.createContext({}),l=function(e){var n=r.a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=l(e.components);return r.a.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=l(t),m=o,f=p["".concat(a,".").concat(m)]||p[m]||u[m]||i;return t?r.a.createElement(f,s(s({ref:n},d),{},{components:t})):r.a.createElement(f,s({ref:n},d))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var d=2;d<i;d++)a[d]=t[d];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);